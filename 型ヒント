# Python型ヒント完全チートシート【実務で使える保存版】

## はじめに
この記事を読めば、Pythonの型ヒントを**0から実務レベルまで**マスターできます。コード1行ずつ丁寧に解説します。

## 目次
1. [型ヒントの基礎](#基礎)
2. [標準的な型](#標準型)
3. [コレクション型](#コレクション)
4. [Optional と Union](#optional-union)
5. [関数の型ヒント](#関数)
6. [クラスの型ヒント](#クラス)
7. [高度な型ヒント](#高度)
8. [実務パターン集](#実務)

---

## <a id="基礎"></a>1. 型ヒントの基礎

### 変数の型ヒント

```python
# 文字列型の変数を宣言（型ヒント: str）
name: str = "田中太郎"

# 整数型の変数を宣言（型ヒント: int）
age: int = 30

# 浮動小数点数型の変数を宣言（型ヒント: float）
price: float = 1999.99

# 真偽値型の変数を宣言（型ヒント: bool）
is_active: bool = True

# 型ヒントは省略可能だが、明示すると可読性が上がる
email = "tanaka@example.com"  # 型ヒントなし（推奨されない）
```

---

## <a id="標準型"></a>2. 標準的な型

```python
# ======== 基本型 ========

# 整数型
user_id: int = 12345

# 浮動小数点数型
tax_rate: float = 0.1

# 文字列型
username: str = "admin"

# 真偽値型
is_verified: bool = False

# ======== 特殊な型 ========

# Any型 - どんな型でもOK（なるべく使わない）
from typing import Any
# 任意の型を受け入れる変数
data: Any = "文字列でもOK"
# 数値に変更してもエラーにならない
data = 123

# None型 - 値が存在しないことを明示
# None型の変数を宣言（初期値なし）
result: None = None
```

---

## <a id="コレクション"></a>3. コレクション型

### Python 3.9以降の書き方（推奨）

```python
# ======== リスト（list） ========

# int型の要素を持つリストを宣言
numbers: list[int] = [1, 2, 3, 4, 5]

# str型の要素を持つリストを宣言
names: list[str] = ["太郎", "花子", "次郎"]

# float型の要素を持つリスト
prices: list[float] = [100.5, 200.0, 300.75]

# ======== 辞書（dict） ========

# キー: str型、値: int型の辞書を宣言
scores: dict[str, int] = {
    "math": 90,      # 数学の点数
    "english": 85,   # 英語の点数
    "science": 92    # 理科の点数
}

# キー: int型、値: str型の辞書
user_names: dict[int, str] = {
    1: "田中",    # ユーザーID 1 の名前
    2: "佐藤",    # ユーザーID 2 の名前
    3: "鈴木"     # ユーザーID 3 の名前
}

# 複雑な辞書型：キー: str、値: int または str
user_info: dict[str, int | str] = {
    "name": "田中",   # 名前（文字列）
    "age": 30,        # 年齢（数値）
    "email": "tanaka@example.com"  # メール（文字列）
}

# ======== タプル（tuple） ========

# 2つのint要素を持つタプル（座標など）
point: tuple[int, int] = (10, 20)

# 3つの要素を持つタプル（型が異なってもOK）
person: tuple[str, int, bool] = ("田中", 30, True)

# 可変長タプル：すべての要素がint型
numbers_tuple: tuple[int, ...] = (1, 2, 3, 4, 5)

# ======== セット（set） ========

# str型の要素を持つセット（重複なし）
tags: set[str] = {"python", "typing", "programming"}

# int型の要素を持つセット
unique_ids: set[int] = {1, 2, 3, 4, 5}
```

### Python 3.8以前の書き方（互換性のため）

```python
# typing モジュールから型をインポート
from typing import List, Dict, Tuple, Set

# List[型] の形式で書く
old_numbers: List[int] = [1, 2, 3]

# Dict[キー型, 値型] の形式で書く
old_scores: Dict[str, int] = {"math": 90}

# Tuple[型1, 型2, ...] の形式で書く
old_point: Tuple[int, int] = (10, 20)

# Set[型] の形式で書く
old_tags: Set[str] = {"python", "typing"}
```

---

## <a id="optional-union"></a>4. Optional と Union

### Optional型（値がNoneの可能性がある）

```python
# Python 3.10以降の書き方（推奨）

# str型またはNoneを取る変数
# | None で「Noneの可能性あり」を表現
nickname: str | None = None

# int型またはNoneを取る変数
user_age: int | None = 25

# 後でNoneに変更可能
user_age = None  # エラーにならない

# ======== 関数での使用例 ========

# 引数user_idでユーザーを検索し、見つからなければNoneを返す
# 戻り値の型: str | None
def find_username(user_id: int) -> str | None:
    # user_idが1の場合
    if user_id == 1:
        # ユーザー名を返す
        return "田中"
    # 見つからない場合はNoneを返す
    return None

# 関数を呼び出して結果を取得
result: str | None = find_username(999)

# Noneチェック（重要！）
if result is not None:
    # Noneでない場合のみ処理（型ガード）
    print(f"ユーザー名: {result}")
else:
    # Noneの場合の処理
    print("ユーザーが見つかりません")
```

```python
# Python 3.9以前の書き方

# typing モジュールからOptionalをインポート
from typing import Optional

# Optional[str] は str | None と同じ意味
old_nickname: Optional[str] = None

# Optional[int] は int | None と同じ意味
old_age: Optional[int] = 25
```

### Union型（複数の型のいずれか）

```python
# Python 3.10以降の書き方（推奨）

# int型またはstr型を取る変数
# | で「または」を表現
user_id: int | str = 12345

# 後でstr型に変更可能
user_id = "USER_12345"  # エラーにならない

# 3つ以上の型も可能
value: int | str | float = 100

# ======== 関数での使用例 ========

# int型またはstr型を受け取り、str型で返す関数
def format_id(id_value: int | str) -> str:
    # どちらの型でもstr型に変換して返す
    return f"ID: {str(id_value)}"

# int型で呼び出し
result1: str = format_id(123)  # "ID: 123"

# str型で呼び出し
result2: str = format_id("ABC")  # "ID: ABC"
```

```python
# Python 3.9以前の書き方

# typing モジュールからUnionをインポート
from typing import Union

# Union[int, str] は int | str と同じ意味
old_user_id: Union[int, str] = 12345

# Union[int, str, float] は int | str | float と同じ意味
old_value: Union[int, str, float] = 100
```

---

## <a id="関数"></a>5. 関数の型ヒント

### 基本的な関数

```python
# 引数a, bは共にint型、戻り値もint型
def add(a: int, b: int) -> int:
    # 2つの数値を足して返す
    return a + b

# 引数nameはstr型、戻り値もstr型
def greet(name: str) -> str:
    # 挨拶文を作成して返す
    return f"こんにちは、{name}さん"

# 戻り値がない場合は -> None
def print_message(message: str) -> None:
    # メッセージを表示（返り値なし）
    print(message)
    # return文がないか、return のみ

# 引数に型ヒント、戻り値にも型ヒント
def calculate_tax(price: int, rate: float) -> float:
    # 税額を計算して返す
    return price * rate
```

### デフォルト引数

```python
# 引数nameは必須、greetingはデフォルト値"こんにちは"
# 両方str型、戻り値もstr型
def create_greeting(name: str, greeting: str = "こんにちは") -> str:
    # 挨拶文を作成して返す
    return f"{greeting}、{name}さん"

# デフォルト値を使用
msg1: str = create_greeting("田中")  # "こんにちは、田中さん"

# 独自の値を指定
msg2: str = create_greeting("佐藤", "おはよう")  # "おはよう、佐藤さん"
```

### 可変長引数

```python
# *argsで可変長の位置引数を受け取る
# args の型: tuple[int, ...]（int型の可変長タプル）
def sum_numbers(*args: int) -> int:
    # すべての引数を合計して返す
    return sum(args)

# 複数の引数を渡せる
total1: int = sum_numbers(1, 2, 3)  # 6
total2: int = sum_numbers(10, 20, 30, 40)  # 100

# **kwargsでキーワード引数を受け取る
# kwargs の型: dict[str, Any]（キー: str、値: Any）
def print_info(**kwargs: str) -> None:
    # すべてのキーワード引数を表示
    for key, value in kwargs.items():
        print(f"{key}: {value}")

# キーワード引数で呼び出し
print_info(name="田中", email="tanaka@example.com")
```

### 複雑な戻り値

```python
# 複数の値を返す（タプル）
# 戻り値: tuple[str, int, bool]
def get_user_info(user_id: int) -> tuple[str, int, bool]:
    # ユーザー情報を3つの値で返す
    name: str = "田中"
    age: int = 30
    is_active: bool = True
    # タプルで返す
    return name, age, is_active

# 戻り値を受け取る（アンパック）
user_name, user_age, active = get_user_info(1)

# リストを返す関数
# 戻り値: list[int]（int型のリスト）
def get_even_numbers(max_num: int) -> list[int]:
    # 0からmax_numまでの偶数を返す
    return [i for i in range(max_num + 1) if i % 2 == 0]

# 辞書を返す関数
# 戻り値: dict[str, int | str]（混合型の辞書）
def create_user_dict(name: str, age: int) -> dict[str, int | str]:
    # ユーザー情報を辞書で返す
    return {"name": name, "age": age}
```

---

## <a id="クラス"></a>6. クラスの型ヒント

### 基本的なクラス

```python
# ユーザー情報を管理するクラス
class User:
    # コンストラクタ：引数の型を指定、戻り値は None
    def __init__(self, name: str, age: int, email: str) -> None:
        # インスタンス変数に型ヒント付きで代入
        self.name: str = name
        self.age: int = age
        self.email: str = email
        # アクティブ状態（デフォルトTrue）
        self.is_active: bool = True
    
    # メソッド：引数なし、戻り値はstr型
    def get_info(self) -> str:
        # ユーザー情報を文字列で返す
        return f"{self.name} ({self.age}歳)"
    
    # メソッド：引数はint型、戻り値はbool型
    def is_adult(self) -> bool:
        # 20歳以上ならTrue、未満ならFalse
        return self.age >= 20
    
    # メソッド：引数はstr型、戻り値なし
    def update_email(self, new_email: str) -> None:
        # メールアドレスを更新
        self.email = new_email

# インスタンスを作成（型ヒント: User）
user: User = User("田中太郎", 25, "tanaka@example.com")

# メソッドを呼び出し
info: str = user.get_info()  # "田中太郎 (25歳)"
is_adult: bool = user.is_adult()  # True
```

### クラス変数とインスタンス変数

```python
# 商品を管理するクラス
class Product:
    # クラス変数：すべてのインスタンスで共有（型ヒント付き）
    tax_rate: float = 0.1  # 消費税率
    
    # コンストラクタ
    def __init__(self, name: str, price: int) -> None:
        # インスタンス変数（各インスタンス固有）
        self.name: str = name
        self.price: int = price
    
    # 税込価格を計算するメソッド
    def get_price_with_tax(self) -> float:
        # price × (1 + tax_rate) を返す
        return self.price * (1 + Product.tax_rate)
    
    # クラスメソッド：税率を変更
    @classmethod
    def set_tax_rate(cls, new_rate: float) -> None:
        # クラス変数を更新
        cls.tax_rate = new_rate

# インスタンスを作成
product: Product = Product("ノートPC", 100000)

# 税込価格を取得
price_with_tax: float = product.get_price_with_tax()  # 110000.0
```

### 継承とオーバーライド

```python
# 基底クラス：動物
class Animal:
    # コンストラクタ
    def __init__(self, name: str) -> None:
        self.name: str = name
    
    # 鳴き声を返すメソッド（サブクラスでオーバーライド）
    def speak(self) -> str:
        # デフォルトのメッセージ
        return "何か音を出す"

# Animalを継承したDogクラス
class Dog(Animal):
    # コンストラクタ（親クラスのコンストラクタを呼び出す）
    def __init__(self, name: str, breed: str) -> None:
        # 親クラスの初期化
        super().__init__(name)
        # 犬種を追加
        self.breed: str = breed
    
    # speakメソッドをオーバーライド
    def speak(self) -> str:
        # 犬の鳴き声を返す
        return "ワンワン"

# Animalを継承したCatクラス
class Cat(Animal):
    # speakメソッドをオーバーライド
    def speak(self) -> str:
        # 猫の鳴き声を返す
        return "ニャー"

# インスタンスを作成
dog: Dog = Dog("ポチ", "柴犬")
cat: Cat = Cat("タマ")

# メソッドを呼び出し
dog_sound: str = dog.speak()  # "ワンワン"
cat_sound: str = cat.speak()  # "ニャー"
```

---

## <a id="高度"></a>7. 高度な型ヒント

### TypeAlias（型エイリアス）

```python
# Python 3.10以降
from typing import TypeAlias

# 複雑な型に名前を付けて再利用
# ユーザー情報の型を定義
UserDict: TypeAlias = dict[str, int | str]

# Emailアドレスのリストの型を定義
EmailList: TypeAlias = list[str]

# 型エイリアスを使用した関数
def create_user(name: str, age: int) -> UserDict:
    # UserDict型の辞書を返す
    return {"name": name, "age": age}

# 型エイリアスを使用した変数宣言
users: list[UserDict] = [
    {"name": "田中", "age": 30},
    {"name": "佐藤", "age": 25}
]

# メールリストを処理する関数
def send_emails(emails: EmailList) -> None:
    # 各メールアドレスに送信（実装は省略）
    for email in emails:
        print(f"送信: {email}")
```

### Callable（関数型）

```python
# typing モジュールからCallableをインポート
from typing import Callable

# 関数を引数に取る関数
# callback の型: 引数(int, int)、戻り値int の関数
def apply_operation(
    a: int, 
    b: int, 
    callback: Callable[[int, int], int]
) -> int:
    # callback関数を実行して結果を返す
    return callback(a, b)

# コールバック関数を定義
def add(x: int, y: int) -> int:
    # 足し算
    return x + y

def multiply(x: int, y: int) -> int:
    # 掛け算
    return x * y

# 関数を引数として渡す
result1: int = apply_operation(5, 3, add)       # 8
result2: int = apply_operation(5, 3, multiply)  # 15
```

### Literal（リテラル型）

```python
# typing モジュールからLiteralをインポート
from typing import Literal

# 特定の値のみを許可する型
# statusは "active", "inactive", "pending" のいずれか
def set_status(status: Literal["active", "inactive", "pending"]) -> None:
    # ステータスを設定（実装は省略）
    print(f"ステータス: {status}")

# 正しい呼び出し
set_status("active")  # OK

# 間違った呼び出し（型チェッカーがエラーを出す）
# set_status("unknown")  # エラー！

# 数値のLiteral
def set_priority(priority: Literal[1, 2, 3]) -> None:
    # 優先度を設定（1, 2, 3のみ許可）
    print(f"優先度: {priority}")

set_priority(1)  # OK
# set_priority(5)  # エラー！
```

### Generic（ジェネリック型）

```python
# typing モジュールからTypeVarとGenericをインポート
from typing import TypeVar, Generic

# 型変数を定義（任意の型を表す）
T = TypeVar('T')

# ジェネリッククラス：どんな型でも格納できるボックス
class Box(Generic[T]):
    # コンストラクタ：T型の値を受け取る
    def __init__(self, value: T) -> None:
        # T型の値を保持
        self.value: T = value
    
    # T型の値を取得するメソッド
    def get(self) -> T:
        # 保持している値を返す
        return self.value
    
    # T型の値を設定するメソッド
    def set(self, value: T) -> None:
        # 新しい値を設定
        self.value = value

# int型のボックスを作成
int_box: Box[int] = Box(123)
num: int = int_box.get()  # 123

# str型のボックスを作成
str_box: Box[str] = Box("Hello")
text: str = str_box.get()  # "Hello"

# ジェネリック関数
def get_first_item(items: list[T]) -> T | None:
    # リストの最初の要素を返す（空の場合はNone）
    if items:
        return items[0]
    return None

# int型のリストで呼び出し
first_num: int | None = get_first_item([1, 2, 3])  # 1

# str型のリストで呼び出し
first_str: str | None = get_first_item(["a", "b"])  # "a"
```

---

## <a id="実務"></a>8. 実務パターン集

### パターン1: API レスポンスの型定義

```python
# typing モジュールから必要な型をインポート
from typing import TypeAlias

# API レスポンスの型を定義
ApiResponse: TypeAlias = dict[str, int | str | list[dict[str, str]]]

# ユーザーAPIのレスポンスを処理する関数
def fetch_user_data(user_id: int) -> ApiResponse:
    # API呼び出し（ダミーデータを返す）
    response: ApiResponse = {
        "user_id": user_id,           # ユーザーID（int）
        "name": "田中太郎",            # 名前（str）
        "email": "tanaka@example.com", # メール（str）
        "orders": [                    # 注文リスト（list[dict]）
            {"order_id": "001", "product": "商品A"},
            {"order_id": "002", "product": "商品B"}
        ]
    }
    # レスポンスを返す
    return response

# 関数を呼び出してデータを取得
user_data: ApiResponse = fetch_user_data(123)

# データを安全に取得（型チェック付き）
user_name: str = str(user_data["name"])
print(f"ユーザー名: {user_name}")
```

### パターン2: データベースモデル

```python
# dataclassesモジュールからdataclassをインポート
from dataclasses import dataclass
# datetimeモジュールをインポート
from datetime import datetime

# @dataclassデコレータでデータクラスを定義
# データベースのUserテーブルに対応するモデル
@dataclass
class UserModel:
    # 各フィールドに型ヒントを付ける
    id: int                      # ユーザーID
    username: str                # ユーザー名
    email: str                   # メールアドレス
    created_at: datetime         # 作成日時
    is_active: bool = True       # アクティブ状態（デフォルト値）
    
    # メソッド：ユーザー情報を文字列で返す
    def to_dict(self) -> dict[str, int | str | bool]:
        # 辞書形式に変換して返す
        return {
            "id": self.id,
            "username": self.username,
            "email": self.email,
            "is_active": self.is_active
        }

# インスタンスを作成
user: UserModel = UserModel(
    id=1,
    username="tanaka",
    email="tanaka@example.com",
    created_at=datetime.now()
)

# メソッドを呼び出し
user_dict: dict[str, int | str | bool] = user.to_dict()
```

### パターン3: バリデーション関数

```python
# 正規表現モジュールをインポート
import re

# メールアドレスのバリデーション
# 引数: str型のメール、戻り値: bool型
def validate_email(email: str) -> bool:
    # メールアドレスの正規表現パターン
    pattern: str = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    # パターンにマッチするか確認
    is_valid: bool = bool(re.match(pattern, email))
    # 結果を返す
    return is_valid

# パスワードのバリデーション
# 引数: str型のパスワード、戻り値: tuple[bool, str]
def validate_password(password: str) -> tuple[bool, str]:
    # パスワードの長さチェック
    if len(password) < 8:
        # 8文字未満の場合はエラー
        return False, "パスワードは8文字以上必要です"
    
    # 数字が含まれているかチェック
    if not any(char.isdigit() for char in password):
        # 数字がない場合はエラー
        return False, "パスワードには数字を含めてください"
    
    # すべてのチェックをパス
    return True, "OK"

# メールバリデーションを実行
is_valid_email: bool = validate_email("test@example.com")  # True
is_valid_email2: bool = validate_email("invalid-email")    # False

# パスワードバリデーションを実行
is_valid_pwd, message = validate_password("test123")
if is_valid_pwd:
    print("パスワードは有効です")
else:
    print(f"エラー: {message}")
```

### パターン4: エラーハンドリング

```python
# Exception を継承したカスタム例外クラス
class UserNotFoundError(Exception):
    # 例外クラスはpassでOK（Exceptionの機能を継承）
    pass

class InvalidUserDataError(Exception):
    pass

# ユーザーを検索する関数（例外を発生させる可能性）
# 引数: int型のuser_id、戻り値: dict型
# 例外: UserNotFoundError を発生させる可能性がある
def find_user(user_id: int) -> dict[str, str]:
    # ダミーのユーザーデータベース
    users: dict[int, dict[str, str]] = {
        1: {"name": "田中", "email": "tanaka@example.com"},
        2: {"name": "佐藤", "email": "sato@example.com"}
    }
    
    # ユーザーIDがデータベースに存在するかチェック
    if user_id not in users:
        # 存在しない場合は例外を発生させる
        raise UserNotFoundError(f"ユーザーID {user_id} が見つかりません")
    
    # ユーザー情報を返す
    return users[user_id]

# ユーザー情報を処理する関数
def process_user(user_id: int) -> None:
    # try-exceptブロックで例外をキャッチ
    try:
        # ユーザーを検索
        user: dict[str, str] = find_user(user_id)
        # 成功した場合の処理
        print(f"ユーザー名: {user['name']}")
    
    # UserNotFoundError例外をキャッチ
    except UserNotFoundError as e:
        # エラーメッセージを表示
        print(f"エラー: {e}")
    
    # その他すべての例外をキャッチ
    except Exception as e:
        # 予期しないエラーを表示
        print(f"予期しないエラー: {e}")

# 正常なケース
process_user(1)  # "ユーザー名: 田中"

# 例外が発生するケース
process_user(999)  # "エラー: ユーザーID 999 が見つかりません"
```

### パターン5: ファイル操作

```python
# pathlibモジュールからPathクラスをインポート
from pathlib import Path

# JSONファイルを読み込む関数
# 引数: Path型のファイルパス、戻り値: dict型またはNone
def read_json_file(file_path: Path) -> dict[str, int | str] | None:
    # ファイルが存在するかチェック
    if not file_path.exists():
        # 存在しない場合はNoneを返す
        return None
    
    # tryブロックでファイル操作
    try:
        # ファイルを読み込みモード、UTF-8エンコーディングで開く
        with file_path.open('r', encoding='utf-8') as f:
            # JSONモジュールをインポート
            import json
            # JSONデータを辞書として読み込む
            data: dict[str, int | str] = json.load(f)
            # データを返す
            return data
    # 例外が発生した場合
    except Exception as e:
        # エラーメッセージを表示
        print(f"ファイル読み込みエラー: {e}")
        # Noneを返す
        return None

# JSONファイルに書き込む関数
# 引数: Path型のファイルパス、dict型のデータ、戻り値: bool型
def write_json_file(file_path: Path, data: dict[str, int | str]) -> bool:
    # tryブロックでファイル操作
    try:
        # ファイルを書き込みモード、UTF-8エンコーディングで開く
        with file_path.open('w', encoding='utf-8') as f:
            # JSONモジュールをインポート
            import json
            # データをJSON形式で書き込み（インデント2、日本語保持）
            json.dump(data, f, indent=2, ensure_ascii=False)
        # 成功したらTrueを返す
        return True
    # 例外が発生した場合
    except Exception as e:
        # エラーメッセージを表示
        print(f"ファイル書き込みエラー: {e}")
        # 失敗したらFalseを返す
        return False

# ファイルパスを作成
config_path: Path = Path("config.json")

# 書き込むデータを準備
config_data: dict[str, int | str] = {
    "app_name": "MyApp",
    "version": "1.0.0",
    "port": 8000
}

# ファイルに書き込み
success: bool = write_json_file(config_path, config_data)

# 書き込みが成功した場合
if success:
    # ファイルを読み込み
    loaded_data: dict[str, int | str] | None = read_json_file(config_path)
    # データが取得できた場合
    if loaded_data:
        print(f"アプリ名: {loaded_data['app_name']}")
```

### パターン6: 非同期処理

```python
# asyncioモジュールをインポート
import asyncio

# 非同期関数：ユーザーデータを取得
# async def で非同期関数を定義
async def fetch_user_async(user_id: int) -> dict[str, int | str]:
    # 非同期でスリープ（API呼び出しをシミュレート）
    await asyncio.sleep(1)
    
    # ユーザーデータを返す
    return {
        "id": user_id,
        "name": f"ユーザー{user_id}"
    }

# 非同期関数：複数のユーザーデータを取得
async def fetch_multiple_users(
    user_ids: list[int]
) -> list[dict[str, int | str]]:
    # 複数の非同期タスクを作成
    # 各user_idに対してfetch_user_asyncを実行
    tasks: list[asyncio.Task[dict[str, int | str]]] = [
        asyncio.create_task(fetch_user_async(uid))
        for uid in user_ids
    ]
    
    # すべてのタスクが完了するまで待機
    results: list[dict[str, int | str]] = await asyncio.gather(*tasks)
    
    # 結果のリストを返す
    return results

# メイン関数（非同期）
async def main() -> None:
    # 取得したいユーザーIDのリスト
    user_ids: list[int] = [1, 2, 3, 4, 5]
    
    # 複数ユーザーのデータを非同期で取得
    users: list[dict[str, int | str]] = await fetch_multiple_users(user_ids)
    
    # 各ユーザー情報を表示
    for user in users:
        print(f"ID: {user['id']}, 名前: {user['name']}")

# 非同期関数を実行
# asyncio.run(main())  # 実際に実行する場合はコメントを外す
```

---

## まとめ

### 型チェックツールの使用

```bash
# mypyのインストール
pip install mypy

# 型チェックを実行
mypy your_script.py

# 厳密モードで実行
mypy --strict your_script.py
```

### ベストプラクティス

1. **すべての関数に型ヒントを付ける**
2. **複雑な型は TypeAlias で名前を付ける**
3. **None の可能性がある場合は必ず `| None` を付ける**
4. **クラスのすべてのメソッドに型ヒントを付ける**
5. **mypy などで定期的に型チェックする**

### よくあるエラーと対処法

```python
# ❌ 間違い：Any型の多用
from typing import Any
def process_data(data: Any) -> Any:  # 型の意味がない
    return data

# ✅ 正しい：具体的な型を指定
def process_data(data: dict[str, int]) -> list[int]:
    return list(data.values())

# ❌ 間違い：Noneチェックなし
def get_name(user_id: int) -> str | None:
    return None if user_id < 0 else "田中"

name = get_name(-1)
print(name.upper())  # エラー！Noneの可能性

# ✅ 正しい：Noneチェックを入れる
name = get_name(1)
if name is not None:
    print(name.upper())  # 安全
```

---

## おわりに

この記事で、Pythonの型ヒントを**基礎から実務レベル**まで網羅しました。型ヒントを使うことで：

- ✅ コードの可読性が向上
- ✅ バグの早期発見
- ✅ IDE の補完機能が強化
- ✅ リファクタリングが安全に

ぜひ実務で活用してください！🐍
